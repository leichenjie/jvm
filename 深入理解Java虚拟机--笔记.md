# 深入理解Java虚拟机--笔记
## 前言
1. Java的技术体系主要由支撑Java程序运行的虚拟机、提供各开发领域接口支持的Java API、Java编程语言及许多第三方Java框架（如Spring等）构成。
## 第一部分 走进Java
1. 我们可以把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK，JDK是用于支持Java程序开发的最小环境。
2. HotSpot VM，是Sun JDK和OpenJDK中所带的虚拟机，也是目前适用范围最广的虚拟机。  
![1.1](images/1.1.png)
3. 早在JDK1.5就已经引入java.util.concurrent包实现了一个粗粒度的并发框架。而在JDK1.7中加入的java.util.concurrent.forkjoin包则是对这个框架的一次重要补充。Fork/Join模式是处理并行编程的一个经典方法。
4. Java8，提供了Lambda支持，极大改善了java语言不适合函数式编程的现状，函数式编程的一个重要的优点就是这样的程序天然的适合并行运行。
## 第二部分 自动内存管理机制
### 第2章 Java内存区域与内存溢出异常
介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题。
### 2.1 运行时数据区域
java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图2-1所示  
![2.1](images/2.1.jpg)  
图2-1 Java虚拟机运行时数据区
#### 2.1.1 程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。  
为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。  
此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
#### 2.1.2 Java虚拟机栈
Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。  
局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型(指向了一条字节码指令的地址）。  
在Java虚拟机规范中。对这个区域规定了两种异常情况：如果线程请求的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展，如果扩展无法申请到足够的内存，就会抛出OutOfMemoryErroe异常。  
#### 2.1.3 本地方法栈
与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。  
#### 2.1.4 Java堆
(1) Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。  
(2) Java堆是垃圾收集器管理的主要区域。现代垃圾收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代。在细致一点的有Eden空间、From survivor空间、To survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓存区域（Thread Local Allocation Buffer，TLAB）。  
(3) Java堆可以处于物理上不连续的内存空间上，只要逻辑上是连续的即可。  
(4) 当前主流的虚拟机内存大小都是按照可扩展来实现的（通过-Xmx和-Xms控制）。  
(5) 如果在堆中没有内存完成示例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
#### 2.1.5 方法区
(1) 方法区（Method Area）与java堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  
(2) 方法区的内存回收目标只要是针对常量池的回收和类型的卸载。  
(3) 当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常
#### 2.1.6 运行时常量池
运行时常量池（Running Constant Pool)是方法区的一部分。---------------String类的intern()方法。
#### 2.1.7 直接内存
在JDK1.4中新引入了NIO（New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式。
### 2.2 HotSpot虚拟机对象探秘
#### 2.2.1 对象的创建
(1) 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的加载过程。  
(2) 在类加载检查过后，接下来虚拟机将为新生对象分配内存。对象所需的内存的大小在类加载完成后便可完全确定。假设Java堆中的内存是绝对规整的，所有用的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的提示器，那分配内存就仅仅是把那个指针向空闲列表的那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump the Pointer)。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。选择哪种分配方式由Java堆是否规整决定的，而Java堆是否规整又由所采用的垃圾回收器是否带有压缩整理功能决定的。
#### 2.2.2 对象的内存布局
(1) 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding)。  
(2) HotSpot虚拟机的对象头包含两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标准、线程持有的锁等。另外一部分是类型指针，即对象指向它的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。另外，如果对象是一个java数组，那么对象头中还必须有一块用于记录数组长度的数据。
(3) 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。
(4) 对齐填充没有特别的含义，仅仅起着占位符的作用。
#### 2.2.3 对象的访问定位
建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式由使用句柄和直接指针两种。  
(1) 如果使用句柄的话，那么java堆将会划分出一块内存来使用句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如图2-2所示。  
![2.2](images/2.2.jpg)  
(2) 如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如图2-3所示  
![2.3](images/2.3.jpg)  
(3) 使用句柄最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。  
(4) 使用直接指针访问方式的最大好处就是速度更快。  

**待解决问题：**  
(1) 代码2-7
## 第三部分 虚拟机执行子系统
## 第四部分 程序编译与代码优化
## 第五部分 高效并发